C#基础概念

1.     面向对象的思想主要包括：继承 多态 封装

●       封装：用抽象的数据类型将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型内部
●       继承：子类拥有父类的所有数据和操作。
●       多态：一个程序中同名的不同方法共存的情况。

有两种形式的多态C 重载与重写。 

2.     什么是装箱和拆箱
装箱（boxing)和拆箱(unboxing)机制使得在C#类型系统中，任何值类型、引用类型和object（对象）类型之间进行转换，这种转换称为绑定连接。简单地说，有了装箱和拆箱的概念，对任何类型的值来说最终都可看作是object类型。  
 1、装箱转换
含义：将一个值类型隐式地转换成一个object类型，或把这个值类型转换成一个被该值类型应用的接口类型，把一个值类型的值装箱，就是创建一个object实例并将值复制给这个object 如：  int I=10;   object obj=I;   也可用显式的方法进行装箱操作： object obj=（object)I;
2、拆箱转换
  和装箱相反，拆箱转换是指将一个对象类型显式地转换成一个值类型，或将一个接口类型显式地转换成一个执行该接口的值类型。
  过程分两步：

首先，检查这个对象实例，看它是否为给定的值类型的装箱值
然后，把这个实例的值拷贝给值类型的变量。如：
    int I=10;
   object obj=I;
Int j=(int)obj; 
3.       重载与override
重载是指针对所继承下来到方法，重新设计其处理方式，为将来原本处理方式覆盖过去。
在派生类要覆盖的方法前加override修饰，而基类的同名方法前加virtual修饰。这样就能实现多态。多态指一个程序中同名的不同方法共存的情况。  有两种形式的多态C 重载与重写。
 

4.       值类型和引用类型
●       值类型的变量本身包含他们的数据，而引用类型的变量包含的是指向包含数据的内存块的引用或叫句柄。
●       值类型变量存储在堆栈。每个程序在执行时都有自己的堆栈，其他程序不能访问。
●       引用类型存储在堆。引用类型存贮实际数据的引用值的地址。
●       C#中的引用类型有4种（类、代表、数组、接口） 

5. 理解委托

代理是C#中的一种新的类型，要把方法作为参数传递给其他方法时，需要用到代理。
方法通过参数获得外界传递给他的数据，并对这些数据进行一定的操作。
C＃通过代理机制来实现，通过参数把一个方法传递给另外一个方法。
代理四步曲：

a．生成自定义代理类：delegate int MyDelegate();
b．用New运算符实例化代理类：
        MyDelegate d = new MyDelegate(MyClass.MyMethod);
c．最后通过实例对象调用方法：int ret = d();
d. 在程序中像调用方法一样应用代理的实例对象调用它指向的方法。 
     delegate int d(int I); 

6.  C#中的接口和类

什么是类?类可以这么理解.类就是功能的集合.类也可以看做是实现一种功能的集合或者方法..接口的概念:什么是接口?接口可以理解为,对类的规定,对类的约束,甚至对整个项目的约束. 一种模版，定义了对象必须实现的方法，其目的就是让这些方法可以作为接口实例被引用。接口不能被实例化。接口是负责功能的定义，项目中通过接口来规范类，操作类以及象类的概念！而类是负责功能的具体实现！在类中也有抽象类的定义，抽象类与接口的区别在于：抽象类是一个不完全的类，类里面有抽象的方法，属性，也可以有具体的方法和属性，需要进一步的专业化。但接口是一个行为的规范，里面的所有东西都是抽象的！一个类只可以继承一个基类也就是父类，但可以实现多个接口 

7. net中读写数据库需要用到的类
Connection DataAdapter DataSet Command DataReader 

8. 理解.net中的垃圾回收机制
如果发现内存不够,则垃圾回收器,将全部对象作为无效对象(被回收对象),然后先将全局变量,static,处于活动中的局部变量,以及当前CG指针指向的对象放入一个表中.然后
会搜索新列表中的对象所引用的对象.加入列表中,其他没有被加入列表的对象都会被回收.非托管对象要记得释放资源就行了吧. 

9. .net的错误处理机制
错误的处理顺序:finally先,catch次之,最后退会try代码..取消此次操作.返回catch中的异常信息.当然,你也可以定制自己的错误处理机制...如果你的异常处理中包含finally块.则此finally无论是否发生异常始终会被执行...

10.   c#中的using和new
using 的用途是为某个namespace建立别名，或者引用存在系统中的其它namespace.
New 用来创建实例，或者覆写方法。 

11.   类和结构的区别
1. 值类型与引用类型
● 结构是值类型：值类型在堆栈上分配地址
● 类是引用类型：引用类型在堆上分配地址
2．继承性
●结构：不能从另外一个结构或者类继承，本身也不能被继承，虽然没有明确sealed声明，可结构是隐式的sealed .
●类：完全可扩展的，除非显式声明sealed， 否则类可以继承其他类和接口，自身也能被继承 。
注：虽然结构不能被继承 ，可结构能够继承接口，方法和类继承接口一样 。
3．内部结构的区别：
结构：
●       没有默认的构造函数，可以添加构造函数
●       没有析构函数
●       没有 abstract 和 sealed(因为不能继承)
●       不能有protected 修饰符
●       可以不用new 初始化
●       在结构中初始化实例字段是错误的

类：
●      有默认的构造函数
●      有析构函数
●      可以使用 abstract 和 sealed
●      有protected 修饰符
●      必须使用new 初始化

 

12.  CLR
公共语言运行时（Common Language Runtime,CLR）,提供了一个可靠而完善的多语言运行环境。CLR是一个软件引擎，用于加载应用程序、检查错误、进行安全许可认证、执行和清空内存。它属于纯动态运行时的一种，它的主要组成部分是虚拟执行引擎VEE（Virtual Execution Enging），它可以打破语言和平台的限制。 

13.  C#的优点 
1.     C#中指针已经消失. 允许对原始指针的有限制的使用.
2.    基于.NET平台的,继承了自动内存管理和垃圾回收的特点.
3.    C#拥有内建的支持来将任何组件转换成一个web service,运行在任何平台上的任何应用程序都可以通过互联网来使用这个服务.
4.     面向对象的

14.  面向对象编程的三大原则
●      继承：都支持类的单一继承，但类可以实现多个接口。所有类都从一个公共的基类继承。
●      封装与可见性：都可决定类成员是否可见。除了C#的internal访问修饰符外，两者可见性机制非常相似
●      多态性：Java和C#都支持某些形式的多态性机制，且两者实现方法非常类似。

 

15.  C#5种类型的可访问性

●      public：成员可以从任何代码访问。
●      protected：成员只能从派生类访问。
●      internal：成员只能从同一程序集的内部访问。
●      protected internal：成员只能从同一程序集内的派生类访问。
●      private：成员只能在当前类的内部访问

 

16.  C#代码在执行前要编译为中间语言，中间语言的主要特征：

● 面向对象和使用接口
● 值类型和引用类型之间的巨大差别
● 强数据类型
● 使用异常来处理错误
● 使用属性(attribute)
 

17.  C#中引用类型
（类、代表、数组、接口）

18.  对象间可能存在的三种关系
●聚合，一个（较复杂的）对象由其他若干（较简单的）对象作为其构成部分，称作聚合。
●关联，对象之间的静态联系（即通过对象属性体现的联系）称作关联。
●继承。
 

=====================================================================
当初学 C# 时是找个人大概问了一下数据类型和分支语句就开始做项目了。这两天又全面的看了一下相关的基础知识（学而时习之嘛），总结了25个问题：



1.静态成员和非静态成员的区别？
2.const 和 static readonly 区别？
3.extern 是什么意思？
4.abstract 是什么意思？
5.internal 修饰符起什么作用？
6.sealed 修饰符是干什么的？
7.override 和 overload 的区别？
8.什么是索引指示器？
9.new 修饰符是起什么作用？
10.this 关键字的含义？
11.可以使用抽象函数重写基类中的虚函数吗？
12.密封类可以有虚函数吗？
13.什么是属性访问器？
14.abstract 可以和 virtual 一起使用吗？可以和 override 一起使用吗？
15.接口可以包含哪些成员？
16.类和结构的区别？
17.接口的多继承会带来哪些问题？
18.抽象类和接口的区别？
19.别名指示符是什么？
20.如何手工释放资源？
21.P/Invoke是什么？
22.StringBuilder 和 String 的区别？
23.explicit 和 implicit 的含义？
24.params 有什么用？
25.什么是反射？

1.	浅复制和深复制
2.	Base64编码的作用以及C#中对其支持。
3.	字符串池机制
	CLR启动的时候，在内部创建一个容器，它以键值对的形式存在，键值是字符串对象内容，值是字符串在托管堆上的引用，当一个新的字符串对象创建的时候CLR检查在这些值中是否已经存在这个字符串对象，如果已经存在就返回对应的值，也就是在托管堆中的引用，如果不存在就在这个容器中中开辟空间存放这个字符串，返回在他的引用。

4.	什么是链式委托，它的执行顺序是怎么样的。
	 多播委托是指一个由委托串成的链表，当链表上的一个委托被回调时，所有链表上该委托的后续委托会被顺序执行。多播委托必须是同类型的.
5.	什么是同步块和同步块索引。
同步块是指.NET维护的同步块数组中的某个元素，负责提供线程同步的操作，当某个线程拥有了某个同步块时，其他线程就在试图访问该同步块时进入等待状态。同步索引是每个堆内对象都会分配的一个字段

6.	查看和设置线程池的上下限。
Threadpool.GetMaxThreads	ThreadPool.SetMaxThreads(workerThreads,completionPortThreads)
7.	Webservice异常机制？
8.	Webservice和Remoting
9.	运行时异常和一般异常有何异同。
10.	String是什么数据类型，ref,out paratms 
11.	Using的使用场合 new
12.	对弱类型集合ArrayList的理解，派生自CollectionBase的自定义强类型集合的泛型集合类如List<T>的演变过程的理解？ 
13.	String和String的区别？
14.	正则表达试
15.	键表有哪些特点?
16.	Javascript是面向对象的，继承如何实现。
17.	CG是什么?时候才用到? 有什么作用?
18.	 Unique 和pk分别是什么？
19.	接口能否继承接口。Implete 抽象类
20.	不能cookie session  application 还有其它什么传参方法。
Cache、Cache、查询字符串

21.	装箱，拆箱何时使用。
22.	面向对对象的特性
24.	Xml的优点,使用场景。
25.	Wcf的webservice的优点。
28.	反射的用途


以下是我做的一份参考答案（C# 语言范畴之内），如果有不准确、不全面的，欢迎各位朋友指正！
 
1.静态成员和非静态成员的区别？ 
答：静态变量使用 static 修饰符进行声明，在类被实例化时创建，通过类进行访问
不带有 static 修饰符声明的变量称做非静态变量，在对象被实例化时创建，通过对象进行访问
一个类的所有实例的同一静态变量都是同一个值，同一个类的不同实例的同一非静态变量可以是不同的值
静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等

示例：
View Code
结果：
Class1's staticStr: Class
tmpObj1's notstaticStr: tmpObj1
tmpObj2's notstaticStr: tmpObj2


2.const 和 static readonly 区别？
答：
const
用 const 修饰符声明的成员叫常量，是在编译期初始化并嵌入到客户端程序
static readonly
用 static readonly 修饰符声明的成员依然是变量，只不过具有和常量类似的使用方法：通过类进行访问、初始化后不可以修改。但与常量不同的是这种变量是在运行期初始化

3.extern 是什么意思？
答：extern 修饰符用于声明由程序集外部实现的成员函数
经常用于系统API函数的调用（通过 DllImport ）。注意，和DllImport一起使用时要加上 static 修饰符
也可以用于对于同一程序集不同版本组件的调用（用 extern 声明别名）
不能与 abstract 修饰符同时使用

4.abstract 是什么意思？
答：
abstract 修饰符可以用于类、方法、属性、事件和索引指示器（indexer），表示其为抽象成员
abstract 不可以和 static 、virtual 一起使用
声明为 abstract 成员可以不包括实现代码，但只要类中还有未实现的抽象成员（即抽象类），那么它的对象就不能被实例化，通常用于强制继承类必须实现某一成员

5.internal 修饰符起什么作用？
答：
internal 修饰符可以用于类型或成员，使用该修饰符声明的类型或成员只能在同一程集内访问
接口的成员不能使用 internal 修饰符

值得注意的是，如果为 internal 成员加上了 protected 修饰符，这时的访问级别为 internal 或 protected。只是看字面意思容易弄错，许多人认为 internal protected 应该是“只有同一个程序集中的子类可以访问”，但其实它表示“同一个程序集中的所有类，以及所有程序集中的子类都可以访问”
 
6.sealed 修饰符是干什么的？
答：
sealed 修饰符表示密封
用于类时，表示该类不能再被继承，不能和 abstract 同时使用，因为这两个修饰符在含义上互相排斥
用于方法和属性时，表示该方法或属性不能再被重写，必须和 override 关键字一起使用，因为使用 sealed 修饰符的方法或属性肯定是基类中相应的虚成员
通常用于实现第三方类库时不想被客户端继承，或用于没有必要再继承的类以防止滥用继承造成层次结构体系混乱

恰当的利用 sealed 修饰符也可以提高一定的运行效率，因为不用考虑继承类会重写该成员


7.override 和 overload 的区别？
答：
override 表示重写，用于继承类对基类中虚成员的实现
overload 表示重载，用于同一个类中同名方法不同参数（包括类型不同或个数不同）的实现


8.什么是索引指示器？
答：
实现索引指示器（indexer）的类可以象数组那样使用其实例后的对象，但与数组不同的是索引指示器的参数类型不仅限于int
简单来说，其本质就是一个含参数属性



9.new 修饰符是起什么作用？
答：
new 修饰符与 new 操作符是两个概念
new 修饰符用于声明类或类的成员，表示隐藏了基类中同名的成员。而new 操作符用于实例化一个类型
new 修饰符只能用于继承类，一般用于弥补基类设计的不足
new 修饰符和 override 修饰符不可同时用在一个成员上，因为这两个修饰符在含义上互相排斥


10.this 关键字的含义？
答：
this 是一个保留字，仅限于构造函数和方法成员中使用
在类的构造函数中出现表示对正在构造的对象本身的引用，在类的方法中出现表示对调用该方法的对象的引用，在结构的构造上函数中出现表示对正在构造的结构的引用，在结构的方法中出现表示对调用该方法的结果的引用
this 保留字不能用于静态成员的实现里，因为这时对象或结构并未实例化
在 C# 系统中，this 实际上是一个常量，所以不能使用 this++ 这样的运算
this 保留字一般用于限定同名的隐藏成员、将对象本身做为参数、声明索引访问器、判断传入参数的对象是否为本身


11.可以使用抽象函数重写基类中的虚函数吗？
答：可以
需使用 new 修饰符显式声明，表示隐藏了基类中该函数的实现
或增加 override 修饰符，表示抽象重写了基类中该函数的实现



12.密封类可以有虚函数吗？
答：可以，基类中的虚函数将隐式的转化为非虚函数，但密封类本身不能再增加新的虚函数



13.什么是属性访问器？
 
答：属性访问器（Property Accessor），包括 get 访问器和 set 访问器分别用于字段的读写操作
其设计目的主要是为了实现面向对象（OO）中的封装思想。根据该思想，字段最好设为private，一个精巧的类最好不要直接把字段设为公有提供给客户调用端直接访问
另外要注意属性本身并不一定和字段相联系

14.abstract 可以和 virtual 一起使用吗？可以和 override 一起使用吗？
答：abstract 修饰符不可以和 static、virtual 修饰符一起使用
abstract 修饰符可以和 override 一起使用


15.接口可以包含哪些成员？
答：接口可以包含属性、方法、索引指示器和事件，但不能包含常量、域、操作符、构造函数和析构函数，而且也不能包含任何静态成员
 
16.类和结构的区别？
答：类：
类是引用类型在堆上分配，类的实例进行赋值只是复制了引用，都指向同一段实际对象分配的内存
类有构造和析构函数
类可以继承和被继承
结构：
结构是值类型在栈上分配（虽然栈的访问速度比较堆要快，但栈的资源有限放），结构的赋值将分配产生一个新的对象。
结构没有构造函数，但可以添加。结构没有析构函数
结构不可以继承自另一个结构或被继承，但和类一样可以继承自接口

 

根据以上比较，我们可以得出一些轻量级的对象最好使用结构，但数据量大或有复杂处理逻辑对象最好使用类。
如：Geoemtry（GIS 里的一个概论，在 OGC 标准里有定义） 最好使用类，而 Geometry 中点的成员最好使用结构

 


17.接口的多继承会带来哪些问题？

答：
C# 中的接口与类不同，可以使用多继承，即一个子接口可以有多个父接口。但如果两个父成员具有同名的成员，就产生了二义性（这也正是 C# 中类取消了多继承的原因之一），这时在实现时最好使用显式的声明


18.抽象类和接口的区别？
答：
抽象类（abstract class）可以包含功能定义和实现，接口（interface）只能包含功能定义
抽象类是从一系列相关对象中抽象出来的概念， 因此反映的是事物的内部共性；
接口是为了满足外部调用而定义的一个功能约定， 因此反映的是事物的外部特性
分析对象，提炼内部共性形成抽象类，用以表示对象本质，即“是什么”
为外部提供调用或功能需要扩充时优先使用接口


19.别名指示符是什么？
答：
通过别名指示符我们可以为某个类型起一个别名
主要用于解决两个命名空间内有同名类型的冲突或避免使用冗余的命名空间
别名指示符在所有命名空间最外层定义，作用域为整个单元文件。如果定义在某个命名空间内，那么它只在直接隶属的命名空间内起作用

20.如何手工释放资源？
答： .NET 平台在内存管理方面提供了GC（Garbage Collection），负责自动释放托管资源和内存回收的工作。但在以下两种情况需要我们手工进行资源释放：
一、由于它无法对非托管资源进行释放，所以我们必须自己提供方法来释放对象内分配的非托管资源，比如你在对象的实现代码中使用了一个COM对象；
二、你的类在运行是会产生大量实例（象 GIS 中的Geometry），必须自己手工释放这些资源以提高程序的运行效率
最理想的办法是通过实现一个接口显式的提供给客户调用端手工释放对象，System 命名空间内有一个 IDisposable 接口，拿来做这事非常合适，省得我们自己再声明一个接口了 

 
21.P/Invoke是什么？
答：
在受控代码与非受控代码进行交互时会产生一个事务（transition） ，这通常发生在使用平台调用服务（Platform Invocation Services），即P/Invoke
如调用系统的 API 或与 COM 对象打交道，通过 System.Runtime.InteropServices 命名空间
虽然使用 Interop 非常方便，但据估计每次调用事务都要执行 10 到 40 条指令，算起来开销也不少，所以我们要尽量少调用事务
如果非用不可，建议本着一次调用执行多个动作，而不是多次调用每次只执行少量动作的原则 

22.StringBuilder 和 String 的区别？
答：
String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder，不要使用 String
另外，对于 String 我们不得不多说几句：
1.它是引用类型，在堆上分配内存
2.运算时会产生一个新的实例
3.String 对象一旦生成不可改变（Immutable）
3.定义相等运算符（== 和 !=）是为了比较 String 对象（而不是引用）的值

23.explicit 和 implicit 的含义？
答：
explicit 和 implicit 属于转换运算符，如用这两者可以让我们自定义的类型支持相互交换
explicti 表示显式转换，如从 A -> B 必须进行强制类型转换（B = (B)A）
implicit 表示隐式转换，如从 B -> A 只需直接赋值（A = B）
隐式转换可以让我们的代码看上去更漂亮、更简洁易懂，所以最好多使用 implicit 运算符。不过！如果对象本身在转换时会损失一些信息（如精度），那么我们只能使用 explicit 运算符，以便在编译期就能警告客户调用端

24.params 有什么用？
答：
params 关键字在方法成员的参数列表中使用，为该方法提供了参数个数可变的能力
它在只能出现一次并且不能在其后再有参数定义，之前可以

25.什么是反射？
答：
反射，Reflection，通过它我们可以在运行时获得各种信息，如程序集、模块、类型、字段、属性、方法和事件
通过对类型动态实例化后，还可以对其执行操作
简单来说就是用string可以在runtime为所欲为的东西，实际上就是一个.net framework内建的万能工厂
一般用于插件式框架程序和设计模式的实现，当然反射是一种手段可以充分发挥其能量来完成你想做的任何事情
 


